declare type Err = {
    path: string[];
    message: string;
};
declare type Success<T> = {
    success: true;
    value: T;
};
declare type Failure = {
    success: false;
    errors: Err[];
};
declare type Result<T> = Success<T> | Failure;
declare type Typed<T = unknown> = (input: unknown) => Result<T>;
declare type Shape = {
    [key: string]: Typed;
};
declare type Infer<T> = T extends Shape ? {
    [K in keyof T]: Infer<T[K]>;
} : T extends Typed<infer U> ? U : never;
declare type Literal = string | number | boolean | null;
declare type Enum = {
    [key: string]: string | number;
};
/**
 * Borrowed from `superstruct`
 * @see https://github.com/ianstormtaylor/superstruct/blob/28e0b32d5506a7c73e63f7e718b23977e58aac18/src/utils.ts#L393
 */
declare type InferTuple<Tuple extends Typed[], Length extends number = Tuple["length"]> = Length extends Length ? number extends Length ? Tuple : _InferTuple<Tuple, Length, []> : never;
declare type _InferTuple<Tuple extends Typed[], Length extends number, Accumulated extends unknown[], Index extends number = Accumulated["length"]> = Index extends Length ? Accumulated : _InferTuple<Tuple, Length, [...Accumulated, Infer<Tuple[Index]>]>;

/**
 * Create a new error object
 * @since 1.0.0
 */
declare const toError: (message: string, path?: string[]) => Err;
/**
 * Create a typed success result
 * @since 1.0.0
 */
declare const success: <T>(value: T) => Success<T>;
/**
 * Create a failure result
 * @since 1.0.0
 */
declare const failure: (...errors: Err[]) => Failure;
/**
 * Fold result into either `onLeft` if it fails or `onRight` if it succeeds.
 * @since 1.1.0
 */
declare const fold: <T, L, R>(result: Result<T>, onLeft: (errors: Err[]) => L, onRight: (value: T) => R) => L | R;

/**
 * Create a new Type that maps an input type to an output type
 * @since 1.0.0
 */
declare const map: <I, O>(type: Typed<I>, onSuccess: (value: I) => Result<O>) => Typed<O>;
/**
 * Check if value is a string
 * @since 1.0.0
 */
declare const string: Typed<string>;
/**
 * Check if value is a number
 * @since 1.0.0
 */
declare const number: Typed<number>;
/**
 * Check if value is a boolean
 * @since 1.0.0
 */
declare const boolean: Typed<boolean>;
/**
 * Check if value is a valid date
 * @since 1.0.0
 */
declare const date: Typed<Date>;
/**
 * Check if value is an array of type T
 * @since 1.0.0
 */
declare const array: <T>(type: Typed<T>) => Typed<T[]>;
/**
 * Check if value is an object with the specified shape
 * @since 1.0.0
 */
declare const object: <T extends Shape>(shape: T) => Typed<Infer<T>>;
/**
 * check if value is a literal
 * @since 1.0.0
 */
declare const literal: <T extends Literal>(constant: T) => Typed<T>;
/**
 * Check if value is of type T or null
 * @since 1.0.0
 */
declare const nullable: <T>(type: Typed<T>) => Typed<T | null>;
/**
 * Check if value is of type T or undefined
 * @since 1.0.0
 */
declare const optional: <T>(type: Typed<T>) => Typed<T | undefined>;
/**
 * Check if value is an enum. This function expects a real TypeScript enum type
 * @since 1.0.0
 */
declare const enums: <T extends Enum, K extends keyof T>(e: T) => Typed<T[K]>;
/**
 * Check if value is a tuple
 * @since 1.0.0
 */
declare const tuple: <A extends Typed<unknown>, B extends Typed<unknown>[]>(types_0: A, ...types_1: B) => Typed<[Infer<A>, ...InferTuple<B, B["length"]>]>;
/**
 * Check if value is any of the specified types
 * @since 1.0.0
 */
declare const union: <A extends Typed<unknown>, B extends Typed<unknown>[]>(types_0: A, ...types_1: B) => Typed<Infer<A> | InferTuple<B, B["length"]>[number]>;
/**
 * A passthrough function which returns its input marked as any.
 * Do not use this unless you really need to, it defeats the purpose of this library.
 * @since 1.0.0
 */
declare const any: Typed<any>;
/**
 * Returns a default value when input is undefined
 * @since 1.0.0
 */
declare const defaulted: <T>(type: Typed<T>, fallback: T) => Typed<T>;
/**
 * Coerce first, then check if value is a string
 * @since 1.0.0
 */
declare const asString: Typed<string>;
/**
 * Coerce first, then check if value is a number
 * @since 1.0.0
 */
declare const asNumber: Typed<number>;
/**
 * Coerce first, then check if value is a valid date
 * @since 1.0.0
 */
declare const asDate: Typed<Date>;

export { Err, Failure, Infer, Result, Success, Typed, any, array, asDate, asNumber, asString, boolean, date, defaulted, enums, failure, fold, literal, map, nullable, number, object, optional, string, success, toError, tuple, union };
