const i=(e,t)=>`Expecting type '${e}'. Got type '${t}'`,c=(e,t=[])=>({path:t,message:e}),u=e=>({success:!0,value:e}),o=(...e)=>({success:!1,errors:e}),f=(e,t)=>t.length?o(...t):u(e),b=(e,t)=>e.map(s=>c(s.message,[String(t),...s.path])),l=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase(),h=(e,t,s)=>e.success?s(e.value):t(e.errors),j=e=>e!==null&&typeof e=="object"&&!Array.isArray(e),v=(e,t)=>s=>{const n=e(s);return n.success?t(n.value):n},y=e=>typeof e=="string"?u(e):o(c(i("string",l(e)))),g=e=>typeof e=="number"?Number.isFinite(e)?u(e):o(c("Expecting value to be a finite 'number'")):o(c(i("number",l(e)))),E=e=>typeof e=="boolean"?u(e):o(c(i("boolean",l(e)))),m=e=>e instanceof Date?Number.isFinite(e.getTime())?u(e):o(c("Expecting value to be a valid 'date'")):o(c(i("date",l(e)))),A=e=>t=>{if(!Array.isArray(t))return o(c(i("array",l(t))));const s=[],n=[];for(let r=0;r<t.length;r++){const a=e(t[r]);a.success?s.push(a.value):n.push(...b(a.errors,r))}return f(s,n)},O=e=>{const t=Object.entries(e);return s=>{if(!j(s))return o(c(i("object",l(s))));const n=Object.create(null),r=[];for(const[a,d]of t){const p=d(s[a]);p.success?n[a]=p.value:r.push(...b(p.errors,a))}return f(n,r)}},$=e=>t=>e===t?u(t):o(c(`Expecting literal '${e}'. Got '${t}'`)),N=e=>t=>t===null?u(t):e(t),S=e=>t=>typeof t=="undefined"?u(t):e(t),D=e=>{const t=Object.values(e);return s=>t.includes(s)?u(s):o(c(`Expecting value to be one of '${t.join(", ")}'. Got '${s}'`))},G=(...e)=>t=>{if(!Array.isArray(t))return o(c(i("array",l(t))));const s=[],n=[];for(let r=0;r<e.length;r++){const a=e[r](t[r]);a.success?s.push(a.value):n.push(...b(a.errors,r))}return f(s,n)},w=(...e)=>t=>{const s=[];for(const n of e){const r=n(t);if(r.success)return r;s.push(...r.errors)}return o(...s)},F=e=>u(e),T=(e,t)=>s=>typeof s=="undefined"?u(t):e(s),k=e=>y(String(e)),C=e=>g(Number(e)),K=e=>m(typeof e=="string"||typeof e=="number"?new Date(e):e);export{F as any,A as array,K as asDate,C as asNumber,k as asString,E as boolean,m as date,T as defaulted,D as enums,o as failure,h as fold,$ as literal,v as map,N as nullable,g as number,O as object,S as optional,y as string,u as success,c as toError,G as tuple,w as union};
