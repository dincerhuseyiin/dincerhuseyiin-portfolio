"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const toMessage=(e,t)=>`Expecting type '${e}'. Got type '${t}'`,toError=(e,t=[])=>({path:t,message:e}),success=e=>({success:!0,value:e}),failure=(...e)=>({success:!1,errors:e}),toResult=(e,t)=>t.length?failure(...t):success(e),mapErrorKey=(e,t)=>e.map(s=>toError(s.message,[String(t),...s.path])),getTypeOf=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase(),fold=(e,t,s)=>e.success?s(e.value):t(e.errors),isPlainObject=e=>e!==null&&typeof e=="object"&&!Array.isArray(e),map=(e,t)=>s=>{const o=e(s);return o.success?t(o.value):o},string=e=>typeof e=="string"?success(e):failure(toError(toMessage("string",getTypeOf(e)))),number=e=>typeof e=="number"?Number.isFinite(e)?success(e):failure(toError("Expecting value to be a finite 'number'")):failure(toError(toMessage("number",getTypeOf(e)))),boolean=e=>typeof e=="boolean"?success(e):failure(toError(toMessage("boolean",getTypeOf(e)))),date=e=>e instanceof Date?Number.isFinite(e.getTime())?success(e):failure(toError("Expecting value to be a valid 'date'")):failure(toError(toMessage("date",getTypeOf(e)))),array=e=>t=>{if(!Array.isArray(t))return failure(toError(toMessage("array",getTypeOf(t))));const s=[],o=[];for(let r=0;r<t.length;r++){const n=e(t[r]);n.success?s.push(n.value):o.push(...mapErrorKey(n.errors,r))}return toResult(s,o)},object=e=>{const t=Object.entries(e);return s=>{if(!isPlainObject(s))return failure(toError(toMessage("object",getTypeOf(s))));const o=Object.create(null),r=[];for(const[n,u]of t){const c=u(s[n]);c.success?o[n]=c.value:r.push(...mapErrorKey(c.errors,n))}return toResult(o,r)}},literal=e=>t=>e===t?success(t):failure(toError(`Expecting literal '${e}'. Got '${t}'`)),nullable=e=>t=>t===null?success(t):e(t),optional=e=>t=>typeof t=="undefined"?success(t):e(t),enums=e=>{const t=Object.values(e);return s=>t.includes(s)?success(s):failure(toError(`Expecting value to be one of '${t.join(", ")}'. Got '${s}'`))},tuple=(...e)=>t=>{if(!Array.isArray(t))return failure(toError(toMessage("array",getTypeOf(t))));const s=[],o=[];for(let r=0;r<e.length;r++){const n=e[r](t[r]);n.success?s.push(n.value):o.push(...mapErrorKey(n.errors,r))}return toResult(s,o)},union=(...e)=>t=>{const s=[];for(const o of e){const r=o(t);if(r.success)return r;s.push(...r.errors)}return failure(...s)},any=e=>success(e),defaulted=(e,t)=>s=>typeof s=="undefined"?success(t):e(s),asString=e=>string(String(e)),asNumber=e=>number(Number(e)),asDate=e=>date(typeof e=="string"||typeof e=="number"?new Date(e):e);exports.any=any,exports.array=array,exports.asDate=asDate,exports.asNumber=asNumber,exports.asString=asString,exports.boolean=boolean,exports.date=date,exports.defaulted=defaulted,exports.enums=enums,exports.failure=failure,exports.fold=fold,exports.literal=literal,exports.map=map,exports.nullable=nullable,exports.number=number,exports.object=object,exports.optional=optional,exports.string=string,exports.success=success,exports.toError=toError,exports.tuple=tuple,exports.union=union;
